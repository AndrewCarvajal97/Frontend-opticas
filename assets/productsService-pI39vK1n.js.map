{"version":3,"mappings":"+CAwDA,MAAMA,UAAwBC,CAAgB,CAC5C,aAAc,CACN,QAMR,MAAM,gBAAyD,CAGzD,IAIK,OACL,MAHe,YAAM,OAAO,wBAAsB,OAGnC,QACf,OAAQ,IACR,QAAS,gCACT,QAAS,EACX,OACc,CACR,UAAI,MAAM,yBAAyB,EAC3C,CAMF,MAAM,sBAAsBC,EAAqD,CAMxE,OACL,MAN0B,MAAM,KAAK,eAAe,GACT,KAAK,SAAS,OACzDC,GAAWA,EAAQ,WAAaD,CAClC,EAIE,OAAQ,IACR,QAAS,4CACT,QAAS,EACX,EAMF,MAAM,eAAeE,EAAyD,CAEtE,MAAAD,GADsB,MAAM,KAAK,eAAe,GAClB,KAAK,SAAS,KAChDA,GAAWA,EAAQ,KAAOC,CAC5B,EAEO,OACL,KAAMD,GAAW,KACjB,OAAQA,EAAU,IAAM,IACxB,QAASA,EAAU,gBAAkB,oBACrC,QAAS,CAAC,CAACA,CACb,EAMF,MAAM,eAAeE,EAA0D,CAE7E,IAAIC,EAAW,CAAC,IADY,MAAM,KAAK,eAAe,GACf,KAAK,QAAQ,EAGhDD,EAAQ,WACVC,EAAWA,EAAS,OAAOH,GAAWA,EAAQ,WAAaE,EAAQ,QAAQ,GAGzEA,EAAQ,QACVC,EAAWA,EAAS,OAAOH,GACzBA,EAAQ,MAAM,cAAc,SAASE,EAAQ,MAAO,YAAa,EACnE,GAGEA,EAAQ,WAAa,SACvBC,EAAWA,EAAS,OAAOH,GAAWA,EAAQ,OAASE,EAAQ,QAAS,GAGtEA,EAAQ,WAAa,SACvBC,EAAWA,EAAS,OAAOH,GAAWA,EAAQ,OAASE,EAAQ,QAAS,GAGtEA,EAAQ,UAAY,SACtBC,EAAWA,EAAS,OAAOH,GAAWA,EAAQ,UAAYE,EAAQ,OAAO,GAIvEA,EAAQ,QACDC,EAAA,KAAK,CAACC,EAAGC,IAAM,CACtB,IAAIC,EAAa,EAEjB,OAAQJ,EAAQ,OAAQ,CACtB,IAAK,QACUI,EAAAF,EAAE,MAAQC,EAAE,MACzB,MACF,IAAK,SACUC,EAAAF,EAAE,OAASC,EAAE,OAC1B,MACF,IAAK,OACHC,EAAaF,EAAE,KAAK,cAAcC,EAAE,IAAI,EACxC,MACF,IAAK,WACUC,EAAAF,EAAE,SAAWC,EAAE,SAC5B,MAGJ,OAAOH,EAAQ,YAAc,OAAS,CAACI,EAAaA,CAAA,CACrD,EAIG,MAAAC,EAAOL,EAAQ,MAAQ,EACvBM,EAAQN,EAAQ,OAAS,GACzBO,GAAcF,EAAO,GAAKC,EAC1BE,EAAWD,EAAaD,EAIvB,OACL,KAHwBL,EAAS,MAAMM,EAAYC,CAAQ,EAI3D,OAAQ,IACR,QAAS,4BACT,QAAS,EACX,EAMF,MAAM,qBAAuD,CACrD,MAAAC,EAAsB,MAAM,KAAK,eAAe,EAChD,CAAE,YAAAC,EAAa,SAAAT,CAAS,EAAIQ,EAAoB,KAM/C,OACL,KALuBR,EAAS,OAChCH,GAAAY,EAAY,SAASZ,EAAQ,EAAE,CACjC,EAIE,OAAQ,IACR,QAAS,yCACT,QAAS,EACX,EAMF,MAAM,mBAAqD,CACnD,MAAAW,EAAsB,MAAM,KAAK,eAAe,EAChD,CAAE,OAAAE,EAAQ,SAAAV,CAAS,EAAIQ,EAAoB,KAM1C,OACL,KALmBR,EAAS,UAC5BU,EAAO,SAASb,EAAQ,EAAE,GAAKA,EAAQ,SAAW,CACpD,EAIE,OAAQ,IACR,QAAS,wCACT,QAAS,EACX,EAMF,MAAM,gBAAkD,CAChD,MAAAW,EAAsB,MAAM,KAAK,eAAe,EAChD,CAAE,YAAAG,EAAa,SAAAX,CAAS,EAAIQ,EAAoB,KAM/C,OACL,KALkBR,EAAS,OAC3BH,GAAAc,EAAY,SAASd,EAAQ,EAAE,CACjC,EAIE,OAAQ,IACR,QAAS,oCACT,QAAS,EACX,EAMF,MAAM,eAAyD,CAGtD,OACL,MAH0B,MAAM,KAAK,eAAe,GAG1B,KAAK,WAC/B,OAAQ,IACR,QAAS,kCACT,QAAS,EACX,EAMF,MAAM,mBAAmBC,EAAmBO,EAAgB,EAAoC,CAC9F,MAAMO,EAAkB,MAAM,KAAK,eAAed,CAAS,EAEvD,IAACc,EAAgB,KACZ,OACL,KAAM,CAAC,EACP,OAAQ,IACR,QAAS,oBACT,QAAS,EACX,EAGF,MAAMC,EAAiBD,EAAgB,KAOhC,OACL,MAPuB,MAAM,KAAK,sBAAsBC,EAAe,QAAQ,GAExC,KACtC,OAAOhB,GAAWA,EAAQ,KAAOC,CAAS,EAC1C,MAAM,EAAGO,CAAK,EAIf,OAAQ,IACR,QAAS,wCACT,QAAS,EACX,EAMF,MAAM,WAAWP,EAAmBgB,EAAmB,EAAkC,CACvF,MAAMF,EAAkB,MAAM,KAAK,eAAed,CAAS,EAEvD,IAACc,EAAgB,KACZ,OACL,KAAM,GACN,OAAQ,IACR,QAAS,oBACT,QAAS,EACX,EAGF,MAAMG,EAAcH,EAAgB,KAAK,SACtBA,EAAgB,KAAK,eAAiBE,EAElD,OACL,KAAMC,EACN,OAAQ,IACR,QAASA,EAAc,oBAAsB,qBAC7C,QAAS,EACX,EAEJ,CAGa,MAAAC,EAAkB,IAAItB","names":["ProductsService","WebServicesBase","categoryId","product","productId","filters","products","a","b","comparison","page","limit","startIndex","endIndex","allProductsResponse","bestsellers","onSale","newArrivals","productResponse","currentProduct","quantity","isAvailable","productsService"],"ignoreList":[],"sources":["../../src/services/productsService.ts"],"sourcesContent":["/**\n * Products Service\n * Maneja todas las operaciones relacionadas con productos\n * Extiende de WebServicesBase siguiendo principios SOLID\n */\n\nimport { WebServicesBase, type ApiResponse } from './webServicesBase';\n\n// Interfaces para tipado fuerte\nexport interface Product {\n  id: string;\n  name: string;\n  category: string;\n  brand: string;\n  price: number;\n  originalPrice: number;\n  discount: number;\n  description: string;\n  features: string[];\n  images: string[];\n  colors?: string[];\n  sizes?: string[];\n  inStock: boolean;\n  stockQuantity: number;\n  rating: number;\n  reviews: number;\n  prescriptionRequired?: boolean;\n}\n\nexport interface ProductCategory {\n  id: string;\n  name: string;\n  description: string;\n  icon: string;\n}\n\nexport interface ProductsResponse {\n  categories: ProductCategory[];\n  products: Product[];\n  bestsellers: string[];\n  newArrivals: string[];\n  onSale: string[];\n}\n\nexport interface ProductFilters {\n  category?: string;\n  brand?: string;\n  priceMin?: number;\n  priceMax?: number;\n  inStock?: boolean;\n  sortBy?: 'price' | 'rating' | 'name' | 'discount';\n  sortOrder?: 'asc' | 'desc';\n  page?: number;\n  limit?: number;\n}\n\nclass ProductsService extends WebServicesBase {\n  constructor() {\n    super();\n  }\n\n  /**\n   * Obtiene todos los productos\n   */\n  async getAllProducts(): Promise<ApiResponse<ProductsResponse>> {\n    // En un entorno real, esto haría una llamada a la API\n    // Por ahora, simulamos leyendo el archivo JSON local\n    try {\n      // Simulación de datos locales (en desarrollo futuro será una llamada real a la API)\n      const response = await import('@/data/products.json');\n      // Cast the response to the expected type\n      return {\n        data: response.default as unknown as ProductsResponse,\n        status: 200,\n        message: 'Products fetched successfully',\n        success: true\n      };\n    } catch (error) {\n      throw new Error('Error fetching products');\n    }\n  }\n\n  /**\n   * Obtiene productos por categoría\n   */\n  async getProductsByCategory(categoryId: string): Promise<ApiResponse<Product[]>> {\n    const allProductsResponse = await this.getAllProducts();\n    const filteredProducts = allProductsResponse.data.products.filter(\n      product => product.category === categoryId\n    );\n\n    return {\n      data: filteredProducts,\n      status: 200,\n      message: 'Products by category fetched successfully',\n      success: true\n    };\n  }\n\n  /**\n   * Obtiene un producto por ID\n   */\n  async getProductById(productId: string): Promise<ApiResponse<Product | null>> {\n    const allProductsResponse = await this.getAllProducts();\n    const product = allProductsResponse.data.products.find(\n      product => product.id === productId\n    );\n\n    return {\n      data: product || null,\n      status: product ? 200 : 404,\n      message: product ? 'Product found' : 'Product not found',\n      success: !!product\n    };\n  }\n\n  /**\n   * Busca productos con filtros\n   */\n  async searchProducts(filters: ProductFilters): Promise<ApiResponse<Product[]>> {\n    const allProductsResponse = await this.getAllProducts();\n    let products = [...allProductsResponse.data.products];\n\n    // Aplicar filtros\n    if (filters.category) {\n      products = products.filter(product => product.category === filters.category);\n    }\n\n    if (filters.brand) {\n      products = products.filter(product => \n        product.brand.toLowerCase().includes(filters.brand!.toLowerCase())\n      );\n    }\n\n    if (filters.priceMin !== undefined) {\n      products = products.filter(product => product.price >= filters.priceMin!);\n    }\n\n    if (filters.priceMax !== undefined) {\n      products = products.filter(product => product.price <= filters.priceMax!);\n    }\n\n    if (filters.inStock !== undefined) {\n      products = products.filter(product => product.inStock === filters.inStock);\n    }\n\n    // Aplicar ordenamiento\n    if (filters.sortBy) {\n      products.sort((a, b) => {\n        let comparison = 0;\n        \n        switch (filters.sortBy) {\n          case 'price':\n            comparison = a.price - b.price;\n            break;\n          case 'rating':\n            comparison = a.rating - b.rating;\n            break;\n          case 'name':\n            comparison = a.name.localeCompare(b.name);\n            break;\n          case 'discount':\n            comparison = a.discount - b.discount;\n            break;\n        }\n\n        return filters.sortOrder === 'desc' ? -comparison : comparison;\n      });\n    }\n\n    // Aplicar paginación\n    const page = filters.page || 1;\n    const limit = filters.limit || 12;\n    const startIndex = (page - 1) * limit;\n    const endIndex = startIndex + limit;\n    \n    const paginatedProducts = products.slice(startIndex, endIndex);\n\n    return {\n      data: paginatedProducts,\n      status: 200,\n      message: 'Products search completed',\n      success: true\n    };\n  }\n\n  /**\n   * Obtiene productos destacados\n   */\n  async getFeaturedProducts(): Promise<ApiResponse<Product[]>> {\n    const allProductsResponse = await this.getAllProducts();\n    const { bestsellers, products } = allProductsResponse.data;\n    \n    const featuredProducts = products.filter(product => \n      bestsellers.includes(product.id)\n    );\n\n    return {\n      data: featuredProducts,\n      status: 200,\n      message: 'Featured products fetched successfully',\n      success: true\n    };\n  }\n\n  /**\n   * Obtiene productos en oferta\n   */\n  async getOnSaleProducts(): Promise<ApiResponse<Product[]>> {\n    const allProductsResponse = await this.getAllProducts();\n    const { onSale, products } = allProductsResponse.data;\n    \n    const saleProducts = products.filter(product => \n      onSale.includes(product.id) || product.discount > 0\n    );\n\n    return {\n      data: saleProducts,\n      status: 200,\n      message: 'On sale products fetched successfully',\n      success: true\n    };\n  }\n\n  /**\n   * Obtiene productos nuevos\n   */\n  async getNewArrivals(): Promise<ApiResponse<Product[]>> {\n    const allProductsResponse = await this.getAllProducts();\n    const { newArrivals, products } = allProductsResponse.data;\n    \n    const newProducts = products.filter(product => \n      newArrivals.includes(product.id)\n    );\n\n    return {\n      data: newProducts,\n      status: 200,\n      message: 'New arrivals fetched successfully',\n      success: true\n    };\n  }\n\n  /**\n   * Obtiene categorías de productos\n   */\n  async getCategories(): Promise<ApiResponse<ProductCategory[]>> {\n    const allProductsResponse = await this.getAllProducts();\n    \n    return {\n      data: allProductsResponse.data.categories,\n      status: 200,\n      message: 'Categories fetched successfully',\n      success: true\n    };\n  }\n\n  /**\n   * Obtiene productos relacionados\n   */\n  async getRelatedProducts(productId: string, limit: number = 4): Promise<ApiResponse<Product[]>> {\n    const productResponse = await this.getProductById(productId);\n    \n    if (!productResponse.data) {\n      return {\n        data: [],\n        status: 404,\n        message: 'Product not found',\n        success: false\n      };\n    }\n\n    const currentProduct = productResponse.data;\n    const categoryProducts = await this.getProductsByCategory(currentProduct.category);\n    \n    const relatedProducts = categoryProducts.data\n      .filter(product => product.id !== productId)\n      .slice(0, limit);\n\n    return {\n      data: relatedProducts,\n      status: 200,\n      message: 'Related products fetched successfully',\n      success: true\n    };\n  }\n\n  /**\n   * Verifica disponibilidad de stock\n   */\n  async checkStock(productId: string, quantity: number = 1): Promise<ApiResponse<boolean>> {\n    const productResponse = await this.getProductById(productId);\n    \n    if (!productResponse.data) {\n      return {\n        data: false,\n        status: 404,\n        message: 'Product not found',\n        success: false\n      };\n    }\n\n    const isAvailable = productResponse.data.inStock && \n                       productResponse.data.stockQuantity >= quantity;\n\n    return {\n      data: isAvailable,\n      status: 200,\n      message: isAvailable ? 'Product available' : 'Insufficient stock',\n      success: true\n    };\n  }\n}\n\n// Instancia singleton del servicio\nexport const productsService = new ProductsService();\n\n/**\n * Función para obtener un producto por su ID\n */\nexport async function getProductById(productId: string): Promise<ApiResponse<Product>> {\n  const response = await fetch(`${import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000/api'}/products/${productId}`);\n  if (!response.ok) {\n    throw new Error('Error al obtener el producto');\n  }\n  return response.json();\n}\n"],"file":"assets/productsService-pI39vK1n.js"}